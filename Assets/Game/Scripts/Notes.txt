MVC框架理解
View最好不要直接GetModel来调用Model,会产生耦合
需要修改Model里的数据时，通过SendEvent发送消息，由Controller来监听事件，在Controller里获取模型并修改数据
Model不能直接监听事件

IEnumerator理解
当需要按秒来计算时，使用协程就可以精准控制秒
此外 回合控制时使用协程而不是在update里写会更方便

Git使用
1.git status 查看当前修改
2.git add . 提交至缓存区
3.git commit -m"第k次提交"  执行提交至本地仓库
4.git push -u origin master 推送至github
5.git log 查看提交记录 
6.git reflog 查看提交日志
7.git reset --hard head（地址） 回滚到某个版本

对象创建
直接说最重要的一句话，在Unity中，继承于MonoBehavior的对象，要避免使用new关键字来创建，
而必须使用AddComponent或Instantiate函数来创建，这种对象也要尽量避免使用构造函数，对应的初始化工作要在对应的Awake和Start函数中进行

协程理解更新
协程中嵌套协程会暂停外层协程 直到里层协程运行结束才会继续外层协程
协程嵌套可以有效控制流程中需要小流程的场景，例如外层控制战斗回合，里层控制动作动画（移动、攻击等等）

防止数据污染的措施
所有卡牌的原始数据都存放于GameModel中的Cards列表中
在战斗中，对卡牌数据的修改都是通过复制一份原始数据，然后修改复制的数据，不会直接修改原始数据
要修改卡牌数据时，对Card GameObject GetComponent<UIUnitStatus>().CardInfo进行修改
如果需要获取卡牌原始数据，直接通过GameModel中的Cards列表获取即可
----------------------------------------------------------------------------------------------------------------------------------------
关于效果的管理
一、效果系统结构
Effect Class (效果基类)：定义效果的基本属性和方法。
具体效果类：继承自 Effect，实现具体效果。
效果管理器：负责管理和调用效果。
Spell.UsingEffect 方法：负责使用并应用效果。
EffectManager单例模式
创建和初始化在EffectManager中进行
----------------------------------------------------------------------------------------------------------------------------------------
关于Buff系统的管理
系统工作流程
BuffManager单例模式

添加 BUFF：
使用 BuffManager.AddBuffToCard 方法为角色添加 BUFF，创建 BUFF 实例并应用到角色。

角色执行行为：
角色执行行为（如攻击、移动）时，触发相应事件（如 OnAttack）。
BuffManager.TriggerEvent 方法通知所有 BUFF 实例处理该事件（如果需要）。

角色行动完成：
角色每次行动完成时，触发 OnActionFinish 事件。
BuffManager.OnActionFinish 方法更新角色的所有 BUFF 实例的状态：
调用 BuffInstance.OnActionFinish 更新 BUFF 效果。
减少 BUFF 实例的剩余持续时间。
移除到期的 BUFF 实例，并撤销其累计效果。

移除 BUFF：
当 BUFF 实例的持续时间到期时，BuffManager 调用 BuffInstance.Remove 移除 BUFF，并从角色的 BUFF 列表中删除。
----------------------------------------------------------------------------------------------------------------------------------------
关于Skill系统管理
1. 抽象类和继承
Skill 抽象类：定义了技能的基本属性和方法，包括技能名称、冷却时间等。使用 abstract 关键字声明了抽象方法 Activate 和虚拟方法 OnAttack、OnTurnStart、OnTurnEnd，以便不同的技能子类实现具体的行为。
2. 单例模式
BuffManager 和 EffectManager：这两个管理器通过单例模式实现，确保在整个游戏中只有一个实例存在，可以全局访问。这样设计能够方便地管理角色的状态修改（如添加 Buff）和执行效果（如播放特效），并与技能系统进行集成。
3. 组合和聚合
SkillInstance 类：用于管理技能的实例状态，包括剩余冷却时间和技能本身。在 SkillManager 类中，使用 List<SkillInstance> 来管理角色所有的技能实例，这种组合关系使得技能管理更加灵活和扩展。
4. 事件驱动
Character 类：使用 C# 的事件（Event）来实现角色行为和状态变化的通知机制。定义了 OnTurnStart、OnAttack 和 OnTurnEnd 事件，这些事件允许其他类订阅并在角色行动时进行响应，例如触发技能和 Buff 的应用。
5. 工厂方法模式
SkillManager 类：负责管理角色的所有技能实例。使用工厂方法模式或者类似的机制（如 ScriptableObject.CreateInstance<Skill>()）来创建不同类型的技能实例，并且通过 AddSkill 方法将技能分配给角色。
6. 策略模式
Skill 和 Buff 类的设计：通过定义抽象基类（如 Skill、Buff）和具体的子类来实现不同的技能和效果。每个技能和 Buff 子类实现自己的 Activate 或者 Apply 方法，具体的行为在运行时动态决定，这种模式允许技能和 Buff 的逻辑在不同情况下灵活变化。

----------------------------------------------------------------------------------------------------------------------------------------
新增加技能/Buff/法术流程
1.基类类完成新技能逻辑
2.在SkillManager中添加新技能 在配置文件中添加新技能
3.在Consts中添加技能名
4.为卡牌添加新技能
----------------------------------------------------------------------------------------------------------------------------------------
所有对字典修改的地方都要判断是否会在其他地方进行修改，如果会，要用线程锁
所有对字典修改的地方都不能在循环中进行，要复制需要修改的部分，然后再进行修改